<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
	<!-- For Favicons -->
    <link rel="icon" type="x-icon" href="favicon.png">
	<!-- For Page Title -->
    <title>UNDERTALE</title>
    <style>
      @-webkit-keyframes rotation {
        from {
          -webkit-transform: rotate(0deg);
        }

        to {
          -webkit-transform: rotate(360deg);
        }
      }

      @-moz-keyframes rotation {
        from {
          -moz-transform: rotate(0deg);
        }

        to {
          -moz-transform: rotate(360deg);
        }
      }

      @-o-keyframes rotation {
        from {
          -o-transform: rotate(0deg);
        }

        to {
          -o-transform: rotate(360deg);
        }
      }

      @keyframes rotation {
        from {
          transform: rotate(0deg);
        }

        to {
          transform: rotate(360deg);
        }
      }

      html {
        background: #FFFFFF;
      }

      body {
        font-family: arial;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        min-height: -webkit-fill-available;
        min-height: fill-available;
        min-height: 100vh; /* Otherwise contents can be covered by an address bar in Safari on iOS 15 */
        min-width: 100vw;
        background: radial-gradient(
          56.63% 56.63% at 50% 43.37%,
          transparent 0%,
          transparent 100%
        );
		background-color: black;
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
		place-items: center;
      }

      body.scrollingDisabled {
        overflow: hidden;
      }

      .emscripten {
        padding-right: 0;
        display: block;
      }

      div.emscripten {
        text-align: center;
		font-family: "Lucida Console", Monaco, monospace;
      }

      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten {
        display: none;
        background-color: black;
        position: flex;
        transition: opacity 5s ease-in;
        -webkit-transition: opacity 5s ease-in;
        opacity: 0;
        filter: blur(0) grayscale(0);
        image-rendering: optimizeSpeed;             /* Older versions of FF          */
        image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
        image-rendering: -webkit-optimize-contrast; /* Safari                        */
        image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
        image-rendering: pixelated;                 /* Awesome future-browsers       */
        -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
      }

      canvas.active {
        animation-name: fadeIn;
        animation-duration: 2s;
        opacity: 1;
      }

      canvas.paused {
        animation-name: blur;
        animation-duration: 0.5s;
        filter: blur(2px) grayscale(1);
      }

      canvas.unpaused {
        animation-name: none;
      }

      canvas.animatedSizeTransitions {
        transition: width 0.3s ease, height 0.3s ease;
      }

      @keyframes fadeIn {
        0% {
          opacity: 0;
        }

        100% {
          opacity: 1;
        }
      }

      @keyframes blur {
        0% {
          filter: blur(0) grayscale(0);
        }

        100% {
          filter: blur(2px) grayscale(1);
        }
      }

      .spinner {
        height: 30px;
        width: 30px;

        -webkit-animation: rotation 0.8s linear infinite;
        -moz-animation: rotation 0.8s linear infinite;
        -o-animation: rotation 0.8s linear infinite;
        animation: rotation 0.8s linear infinite;

        border: 5px solid #bdff00;
        border-top: 5px solid #719900;
        border-radius: 100%;
      }

      #status {
        display: inline-block;
        vertical-align: top;
        font-weight: bold;
        color: white;
      }

      #progress {
        width: 250px;
        height: 10px;
        -webkit-appearance: none;
        appearance: none;
        padding: 5px;
      }

      /* Determines the style of the background of the progress bar */
      progress[value]::-webkit-progress-bar {
        background-color: #8492a6;
        height: 10px;
        border-radius: 15px;
      }
      /* Determines the style of the completed part of the progress bar */
      progress[value]::-webkit-progress-value {
        background-image: -webkit-linear-gradient(left, #719900, #bdff00);
        height: 10px;
        border-radius: 15px;
      }

      div.loading {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: none;
      }
      div.loading > * {
        padding: 10px;
        margin: 10px;
      }

      .output-container {
        text-align: center;
        margin-top: auto;
      }
      .output-button {
        border: none;
        width: 200px;
        height: 25px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        background-color: black;
        color: white;
		outline-color: #20c20e;
		outline-style: dashed;
        font-family: "Lucida Console", Monaco, monospace;
      }

      #output {
        display: none;
        height: 200px;
        background-color: black;
        color: white;
        font-family: "Lucida Console", Monaco, monospace;
        outline: none;
        border: none;
        padding: 0;
        width: 100%;
      }

      #message-container {
        display: none;
        min-height: 50px;
        background-color: rgba(20, 20, 20, 0.5);
        outline: none;
        border: none;
        padding: 0;
        width: 100%;
        position: absolute;
        top: 0;
      }

      #messages {
        margin-left: 50px;
        color: white;
        font-family: "Lucida Console", Monaco, monospace;
        outline: none;
        border: none;
        padding: 0;
      }

      img.qrCode {
         opacity: 1.0;
         width: 50%;
         height: 50%;
      }

      #pauseMenuContainer {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #pauseMenuContainer[hidden] {
        display: none !important;
        opacity: 0;
      }

      #pauseMenuBorder {
        background: linear-gradient(135deg, #FA1E4E, transparent 40%);
        padding: 1px;
        border-radius: 4px;
        clip-path: polygon(10.5px 0, 100% 0, 100% 100%, 0 100%, 0 10.5px);
        width: 70vw;
        max-width: 400px;
      }

      #pauseMenu {
        display: flex;
        flex-direction: column;
        padding: 60px 30px 60px 30px;
        background: linear-gradient(180deg, #2E273F 16.15%, rgba(46, 39, 63, 0.79) 56.25%, #2E273F 91.15%);
        border-radius: 4px;
        clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
        animation-name: fadeIn;
        animation-duration: 0.5s;
        opacity: 1;
      }

      #pauseMenu button {
        font-weight: 500;
        font-size: 17px;
        color: white;
        background: #FA1E4E;
        border: 1px solid #FA1E4E;
        border-radius: 6px;
        padding: 12px 24px;
        margin: 5px 0;
        -webkit-user-select: none;
        user-select: none;
      }

      #pauseMenu button#quitButton {
        background: #FA1E4E40;
      }

      #pauseMenu button:hover {
        filter: brightness(1.15);
      }

      #pauseMenu button:active {
        filter: brightness(0.85);
      }

      #pauseMenu button[hidden] {
        display: none;
      }

      #upload-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        color: white;
        font-family: "Lucida Console", Monaco, monospace;
      }

      /* Mobile Controls */
      #mobile-controls {
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 50%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 9999;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        flex-direction: row;
      }

      body.mobile-controls-active #canvas {
        height: 50vh !important;
        width: 100vw !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
      }
      
      .joystick-area {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
      }

      .joystick-base {
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        position: relative;
      }

      .joystick-stick {
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }

      .buttons-area {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
      }

      .control-btn {
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        color: white;
        font-size: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: monospace;
        user-select: none;
      }
      
      .control-btn:active, .control-btn.active {
        background: rgba(255, 255, 255, 0.5);
      }
    </style>
  </head>
  <body>
    <canvas
      class="emscripten"
      id="canvas"
      oncontextmenu="event.preventDefault()"
      tabindex="-1"
    >
    </canvas>
    <div id="pauseMenuContainer" hidden>
      <div id="pauseMenuBorder">
        <div id="pauseMenu">
          <button id="resumeButton" onclick="resume()">
            Resume
          </button>
          <button id="quitButton" onclick="quitIfSupported()">
            Quit
          </button>
        </div>
        </div>
    </div>
    <div id="mobile-controls">
        <div class="joystick-area">
            <div class="joystick-base" id="joystick-base">
                <div class="joystick-stick" id="joystick-stick"></div>
            </div>
        </div>
        <div class="buttons-area">
            <div class="control-btn" data-key="90">Z</div>
            <div class="control-btn" data-key="88">X</div>
            <div class="control-btn" data-key="67">C</div>
        </div>
    </div>
    <div class="loading" style="display: none;">
      <div class="spinner" id="spinner"></div>
      <div class="emscripten" id="status">Downloading...</div>

      <progress value="0" max="100" id="progress" hidden="1"></progress>
    </div>
    <div class="output-container" id="output-container">
	  <!-- Stock Toggle Console Button -->
      <button class="output-button" onclick="toggleConsole()" title="Lists Console Output and Loading Progress"+>
        Toggle Console
      </button>
	  <!-- Go to Github Repo Button -->
      <button id="QRButton" class="output-button" onclick="togglegithub()" title="Sends you to My Github Repository of this Project"+>
        Visit Github Repo
      </button>
	  <!-- CLear Site Cache Button -->
      <button id="QR2Button" class="output-button" onclick="toggleclear_site_cache()" title="Fixes Crashes due to the Website being Updated, but also Deletes ALL Saves, so Continue with Caution"+>
        Clear Site Cache
      </button>
		<!-- Enable FPS Counter Bookmarklet Button -->
      <button class="output-button" id="stats-button" onclick="toggleFPS()" title="Enables External FPS Counter"+>
        Enable FPS Counter
      </button>
	    <!-- Go to Web Port Website Button -->
      <button class="output-button" id="share-button" onclick="togglewebports()" title="Sends you to My Personal Website with a List of All My Web Ports"+>
        View All Web Ports
      </button>
	    <!-- Join Discord Server Button -->
	  <button class="output-button" onclick="togglejoin_discord()" title="Press to Join My Discord Server for Info and Updates"+>
        Join Discord Server
      </button>
	    <!-- Background Color Changer Button -->
      <input id="colorpicker" type="color" onchange="changecolor(this)" title="Changes Color of the Website's Background"+>
      <textarea id="output" rows="8"></textarea>
    </div>

    <div id="upload-overlay">
        <h2>Game Setup</h2>
        <div id="setup-options" style="display: flex; gap: 20px; margin-bottom: 20px;">
            <button id="btn-mode-upload" style="padding: 10px; font-size: 1.1em; cursor: pointer; font-family: inherit;">Upload Game Files</button>
            <button id="btn-mode-internet" style="padding: 10px; font-size: 1.1em; cursor: pointer; font-family: inherit;">Load from Internet</button>
        </div>
        
        <div id="upload-form" style="display: none; flex-direction: column; gap: 10px; text-align: left;">
            <label>runner.js: <input type="file" id="file-js"></label>
            <label>game.unx: <input type="file" id="file-game"></label>
            <label>runner.data: <input type="file" id="file-data"></label>
            <label>runner.wasm: <input type="file" id="file-wasm"></label>
            <label>audio-worklet.js (optional): <input type="file" id="file-audio"></label>
            <button id="start-game-btn" style="font-size: 1.2em; padding: 10px; margin-top: 10px; font-family: inherit;">Start Game</button>
        </div>
    </div>

    <div id="message-container">
      <div id="messages">
      </div>
    </div>
    <script type="text/javascript">
	// Background Color Changer Function
	function changecolor(el) {
		document.body.style.backgroundColor = el.value;
	}
	
      const CHANGE_ASPECT_RATIO = true;
		// Main Page Elements
      var bodyElement = document.getElementsByTagName("body")[0];
      var statusElement = document.getElementById("status");
      var progressElement = document.getElementById("progress");
      var spinnerElement = document.getElementById("spinner");
      var canvasElement = document.getElementById("canvas");
      var outputElement = document.getElementById("output");
      var outputContainerElement = document.getElementById("output-container");
      var qrElement = document.getElementById("QRCode");
      var qr2Element = document.getElementById("QR2Code");
      var qrButton = document.getElementById("QRButton");
      var qr2Button = document.getElementById("QR2Button");
      var pauseMenu = document.getElementById("pauseMenuContainer");
      var resumeButton = document.getElementById("resumeButton");
      var quitButton = document.getElementById("quitButton");

      const messageContainerElement = document.getElementById("message-container");
      const messagesElement = document.getElementById("messages");
      let rollbackMessages = [];
	  
	  // BAD STUFF IN CONSOLE | DO NOT DISPLAY!!!
	  const CONSOLE_layer_set_visible = "layer_set_visible() - could not find specified layer in current room";
	  const CONSOLE_layer_tilemap_get_id = "layer_tilemap_get_id() - specified tilemap not found";
	  const CONSOLE_layer_depth = "layer_depth() - can't find specified layer";
	  const CONSOLE_draw_tilemap = "draw_tilemap() - couldn't find specified tilemap";
	  const CONSOLE_layer_get_all_elements = "layer_get_all_elements() - can't find specified layer"; // biggest pain in the ass
	  // crack
	  console.log("*************************");
	  console.log("BetterRunner v1.2");
	  console.log("_____by burnedpopcorn180");
	  console.log("*************************");

      let clearRollbackMessagesTimeoutId = -1;
      const showRollbackMessage = function (message) {
        let messages = "";
        rollbackMessages.push(message);
        rollbackMessages.forEach(m => messages += "<p>" + m + "</p>");

        messagesElement.innerHTML = messages;
        messageContainerElement.style.display = 'block';

        if (clearRollbackMessagesTimeoutId === -1) {
          clearTimeout(clearRollbackMessagesTimeoutId);
        }
        clearRollbackMessagesTimeoutId = setTimeout(clearRollbackMessages, 5000);
      };

      const clearRollbackMessages = function () {
        clearRollbackMessagesTimeoutId = -1;
        rollbackMessages = [];
        messageContainerElement.style.display = 'none';
      };
		
	  // for displaying contents of console to display as a single line of text
	  // stopload is set to 0, as to initialize it
	  var loadprogress = 0;
		
      var startingHeight, startingWidth;
      var startingAspect;
      var Module = {
        preRun: [],
        postRun: [],
        print: (function () {
          var element = document.getElementById("output");
          if (element) element.value = ""; // clear browser cache
          return function (text) {
		  
		  // for displaying contents of console to display as a single line of text
		  // if loading has started
			if (text === "Starting WAD") {
			// tells if statement below to display ALL loading strings
				loadprogress += 1;
			}
	  
			// if loading has started
			if (loadprogress === 1) {
			// allow console to be displayed as text on-screen
				Module.setStatus(text);
			}
			// if game has started
			// greater than or equal to just in case
			else if (loadprogress >= 2) {
			// then set load text to nothing
				Module.setStatus("");
			}
		    // back to normal shit
			
            if (arguments.length > 1)
              text = Array.prototype.slice.call(arguments).join(" ");
			// for normal console
			if (text != CONSOLE_layer_set_visible && text != CONSOLE_layer_tilemap_get_id && text != CONSOLE_layer_depth && text != CONSOLE_draw_tilemap && text != CONSOLE_layer_get_all_elements)
				{console.log(text);}
            if (text === "Entering main loop.") {
              // It seems that this text ensures game is loaded.
              ensureAspectRatio();
			  // below are custom
			  // stops loading text on game run
			  loadprogress += 1;

			  // TRUE END of custom shit
            }
            if (element) {
				// check if bad strings are there, and if not, display text to console box
				if (text != CONSOLE_layer_set_visible && text != CONSOLE_layer_tilemap_get_id && text != CONSOLE_layer_depth && text != CONSOLE_draw_tilemap && text != CONSOLE_layer_get_all_elements)
					{element.value += text + "\n";}
				element.scrollTop = element.scrollHeight; // focus on bottom
            }
          };
        })(),
        printErr: function (text) {
          if (arguments.length > 1)
            text = Array.prototype.slice.call(arguments).join(" ");
          console.error(text);
        },
        canvas: (function () {
          var canvas = document.getElementById("canvas");

          return canvas;
        })(),
        setStatus: function (text) {
          if (!Module.setStatus.last)
            Module.setStatus.last = { time: Date.now(), text: "" };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2]) * 100;
            progressElement.max = parseInt(m[4]) * 100;
            progressElement.hidden = false;
            spinnerElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;

            // If there are no status text, we are finished and can display
            // the canvas and hide the spinner
            if (!text) {
              spinnerElement.style.display = "none";
              canvasElement.style.display = "block";
            }
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function (left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(
            left
              ? "Preparing... (" +
                  (this.totalDependencies - left) +
                  "/" +
                  this.totalDependencies +
                  ")"
              : "All downloads complete."
          );
        },
      };
      Module.setStatus("Downloading...");
      window.onerror = function (event) {
        // TODO: do not warn on ok events like simulating an infinite loop or exitStatus
        Module.setStatus("Exception thrown, see JavaScript console");
        spinnerElement.style.display = "none";
        Module.setStatus = function (text) {
          if (text) Module.printErr("[post-exception status] " + text);
        };
      };

      // Route URL GET parameters to argc+argv
      if (typeof window === "object") {
        Module['arguments'] = window.location.search.substr(1).trim().split('&');
        // If no args were passed arguments = [''], in which case kill the single empty string.
        if (!Module['arguments'][0]) {
          Module['arguments'] = [];
        }
      }
	  
	  // All Button Functions
	  
		// Stock Toggle Console Function
      function toggleConsole() {
        var isShown = outputElement.style.display === "flex";
        if (isShown) {
          outputElement.style.display = "none";
          outputElement.scrollIntoView(false);
        } else {
          outputElement.style.display = "flex";
          outputElement.scrollIntoView(true);
        }
      }
		// Go To Github Function
      function togglegithub() {
	    window.open("https://github.com/burnedpopcorn/Pizza-Tower-1.1.0-Web-Port", '_blank').focus();
      }
		// Clear Site Cache Function
      function toggleclear_site_cache() {
	  // Trigger Choice Popup
		if (confirm("This Will Clear Site Cache\nThis will ALSO Clear ALL SAVES\nONLY do this if the Site has recently been Updated\nand if you are experiencing crashes relating to texture loading\nContinue?")) {
		// User clicked OK
		
		// Clear All IndexedDB Databases
		(async () => {
			const dbs = await window.indexedDB.databases();
			dbs.forEach(db => { window.indexedDB.deleteDatabase(db.name) });
			})();
			
		// 
		alert("All Site Cache Has been Cleared!\nPlease reload the Page");
		} else {
		// User clicked Cancel
		// Do nothing
		}
	  }

		// Enable FPS Counter Button
	  var stopfps = 0;
      function toggleFPS() {
	  // to stop it from making multiple instances after 1 has already been made
	  stopfps += 1
	  // if pressed ONLY once
	  if (stopfps === 1) {
	    window.location.href = "javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()"
        }
		// so it can't go crazy high, but can't be activated again
		if (stopfps >= 5) {
		stopfps = 2;
		}
	  }
	    // Go To Website of Web Ports Function
	  function togglewebports() {
		window.open("https://burnedwebsite.vercel.app/projects/", '_blank').focus();
	  }
	    // Join Discord Function
	  function togglejoin_discord() {
	    window.open("https://discord.gg/3dPTpruHhc", '_blank').focus();
	  }
		// End of Button Functions

      var g_pWadLoadCallback = undefined;
      function setWadLoadCallback( _wadLoadCallback ) 
      {
        g_pWadLoadCallback = _wadLoadCallback;
      }

      var g_pAddAsyncMethod = -1;

      function setAddAsyncMethod( asyncMethod )
      {
        g_pAddAsyncMethod = asyncMethod;
      }

      var g_pJSExceptionHandler = undefined;

      function setJSExceptionHandler( exceptionHandler )
      {
        if (typeof exceptionHandler == "function") {
            g_pJSExceptionHandler = exceptionHandler;
        } // end if
      } // end setJSExceptionHandler

      function hasJSExceptionHandler()
      {
        return (g_pJSExceptionHandler != undefined) && (typeof g_pJSExceptionHandler == "function");
      } // end hasJSExceptionHandler

      function doJSExceptionHandler( exceptionJSON )
      {
        if (typeof g_pJSExceptionHandler == "function") {
          var exception = JSON.parse( exceptionJSON );
          g_pJSExceptionHandler( exception );
        } // end if
      } // end doJSExceptionHandler

		// Get Files
      function manifestFiles()
      {
        return [ "runner.data",
"runner.js",
"runner.wasm",
"audio-worklet.js",
"game.unx" ].join( ";");
      }

		// Verify Files
      function manifestFilesMD5()
      {
        return [ "f27d559c3b646eb1b6f3a14786946e2d",
"db5d7a12d2cd866bf536f8ce8c8ffb94",
"591f58ecebef9006336731fff76594fb",
"e8f1e8db8cf996f8715a6f2164c2e44e",
"b1e763db5c753fc5928976defdaccaae" ];
      }

      function onFirstFrameRendered()
      {
          //console.log("First frame rendered!");
      }

      function onGameSetWindowSize(width,height)
      {
          if (startingHeight === undefined && startingWidth === undefined) {
              console.log("Initial window size set to width: " + width + ", height: " + height);

              startingHeight = height;
              startingWidth = width;
              startingAspect = startingWidth / startingHeight;
          }
      }

      function ensureAspectRatio() {
        if (canvasElement === undefined) {
          return;
        }

        if (!CHANGE_ASPECT_RATIO) {
          return;
        }
        
        if (startingHeight === undefined && startingWidth === undefined) {
          return;
        }

        canvasElement.classList.add("active");

        const maxWidth = window.innerWidth;
        const maxHeight = window.innerHeight;
        var newHeight, newWidth;

        // Find the limiting dimension.
        var heightQuotient = startingHeight / maxHeight;
        var widthQuotient = startingWidth / maxWidth;

        if (heightQuotient > widthQuotient) {
          // Max out on height.
          newHeight = maxHeight;
          newWidth = newHeight * startingAspect;
        } else {
          // Max out on width.
          newWidth = maxWidth;
          newHeight = newWidth / startingAspect;
        }

        canvasElement.style.height = newHeight + "px";
        canvasElement.style.width = newWidth + "px";
      }
		// To Pause when it detects the Tab is inactive
      function pause() { // Don't change the name - GX Mobile calls it when the app becomes inactive.
        if (!canvasElement.classList.contains("active")) { // Wait for the canvas to load.
          return
        }
        
        GM_pause();
        pauseMenu.hidden = false;
        canvasElement.classList.add("paused");
      }
		// To Resume when it detects the Tab is Active
      function resume() {
        GM_unpause();
        pauseMenu.hidden = true;
        canvasElement.classList.remove("paused");
        canvasElement.classList.add("unpaused");
        enterFullscreenIfSupported();
        lockOrientationIfSupported();
      }

      function quitIfSupported() {
        if (window.oprt && window.oprt.closeTab) { /* GX Mobile API */
          window.oprt.closeTab();
        } else if (window.chrome && window.chrome.runtime && window.chrome.runtime.sendMessage) {
          window.chrome.runtime.sendMessage('mpojjmidmnpcpopbebmecmjdkdbgdeke', { command: 'closeTab' })
        }
      }

      function enterFullscreenIfSupported() {
        if (!window.oprt || !window.oprt.enterFullscreen) { /* GX Mobile API */
          return;
        }

        window.oprt.enterFullscreen();
        let viewStatus = GM_get_view_status();
        viewStatus.fullscreen = true;
        GM_set_view_status(viewStatus);
      }

      function lockOrientationIfSupported() {
        if (!window.oprt || !window.oprt.lockPortraitOrientation || !window.oprt.lockLandscapeOrientation) { /* GX Mobile API */
          return;
        }

        let viewStatus = GM_get_view_status();
        if (viewStatus.landscape === true && viewStatus.portrait === false) {
          window.oprt.lockPortraitOrientation();
        } else if (viewStatus.landscape === false && viewStatus.portrait === true) {
          window.oprt.lockPortraitOrientation();
        }
      }
		// uh, shit that no one cares about
      const resizeObserver = new ResizeObserver(() => {
        window.requestAnimationFrame(ensureAspectRatio);
        setTimeout(() => window.requestAnimationFrame(ensureAspectRatio), 100);
      });
      resizeObserver.observe(document.body);
		
		// Disable Scrolling on Mobile
      if (/Android|iPhone|iPod/i.test(navigator.userAgent)) {
        bodyElement.className = "scrollingDisabled";
        canvasElement.classList.add("animatedSizeTransitions");
        outputContainerElement.hidden = true;
        initMobileControls();
      }

      document.addEventListener("visibilitychange", (event) => {
        if (document.visibilityState != "visible") {
          pause();
        }
      });

      window.addEventListener("load", (event) => {
        if ((!window.oprt || !window.oprt.enterFullscreen) && (!window.chrome || !window.chrome.runtime || !window.chrome.runtime.sendMessage)) {
          quitButton.hidden = true;
        }
      });

      setWadLoadCallback(() => {
        enterFullscreenIfSupported();
        lockOrientationIfSupported();
      });

      // Mobile Controls Logic
      function initMobileControls() {
          var controls = document.getElementById('mobile-controls');
          if (!controls) return;
          
          controls.style.display = 'flex';
          document.body.classList.add('mobile-controls-active');
          
          // Button Logic
          var buttons = document.querySelectorAll('.control-btn');
          buttons.forEach(function(btn) {
              var keyCode = parseInt(btn.getAttribute('data-key'));
              
              btn.addEventListener('touchstart', function(e) {
                  e.preventDefault();
                  btn.classList.add('active');
                  simulateKey(keyCode, 'keydown');
              });
              
              btn.addEventListener('touchend', function(e) {
                  e.preventDefault();
                  btn.classList.remove('active');
                  simulateKey(keyCode, 'keyup');
              });
          });
          
          // Joystick Logic
          var base = document.getElementById('joystick-base');
          var stick = document.getElementById('joystick-stick');
          var activeTouchId = null;
          var center = { x: 0, y: 0 };
          var maxDist = 35; // Max movement radius
          
          var keys = { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39 };
          var currentKeys = { UP: false, DOWN: false, LEFT: false, RIGHT: false };
          
          function updateKeys(x, y) {
              var threshold = 10;
              var newKeys = {
                  UP: y < -threshold,
                  DOWN: y > threshold,
                  LEFT: x < -threshold,
                  RIGHT: x > threshold
              };
              
              for (var key in keys) {
                  if (newKeys[key] !== currentKeys[key]) {
                      simulateKey(keys[key], newKeys[key] ? 'keydown' : 'keyup');
                      currentKeys[key] = newKeys[key];
                  }
              }
          }
          
          base.addEventListener('touchstart', function(e) {
              e.preventDefault();
              var touch = e.changedTouches[0];
              activeTouchId = touch.identifier;
              var rect = base.getBoundingClientRect();
              center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
              handleJoystickMove(touch.clientX, touch.clientY);
          });
          
          base.addEventListener('touchmove', function(e) {
              e.preventDefault();
              for (var i = 0; i < e.changedTouches.length; i++) {
                  if (e.changedTouches[i].identifier === activeTouchId) {
                      handleJoystickMove(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                      break;
                  }
              }
          });
          
          var endJoystick = function(e) {
              e.preventDefault();
              for (var i = 0; i < e.changedTouches.length; i++) {
                  if (e.changedTouches[i].identifier === activeTouchId) {
                      activeTouchId = null;
                      stick.style.transform = 'translate(-50%, -50%)';
                      updateKeys(0, 0);
                      break;
                  }
              }
          };
          
          base.addEventListener('touchend', endJoystick);
          base.addEventListener('touchcancel', endJoystick);
          
          function handleJoystickMove(clientX, clientY) {
              var dx = clientX - center.x;
              var dy = clientY - center.y;
              var dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist > maxDist) {
                  var angle = Math.atan2(dy, dx);
                  dx = Math.cos(angle) * maxDist;
                  dy = Math.sin(angle) * maxDist;
              }
              
              stick.style.transform = 'translate(calc(-50% + ' + dx + 'px), calc(-50% + ' + dy + 'px))';
              updateKeys(dx, dy);
          }
      }

      function simulateKey(keyCode, type) {
        var evt = document.createEvent("Events");
        evt.initEvent(type, true, true);
        evt.keyCode = keyCode;
        evt.which = keyCode;
        window.dispatchEvent(evt);
      }
    </script>
	<!-- Load Main Game Runner JS File -->
    <script type="text/javascript">
      // Setup UI logic
      document.getElementById('btn-mode-upload').addEventListener('click', function() {
          document.getElementById('setup-options').style.display = 'none';
          document.getElementById('upload-form').style.display = 'flex';
      });

      document.getElementById('btn-mode-internet').addEventListener('click', function() {
          document.getElementById('upload-overlay').style.display = 'none';
          document.querySelector('.loading').style.display = 'flex';
          
          var baseUrl = "https://www.autistici.org/burnedprojects/UNDERTALE/";
          
          // Setup Module.locateFile
          Module.locateFile = function(path, prefix) {
              return baseUrl + path;
          };
          
          // Intercept Fetch
          var originalFetch = window.fetch;
          window.fetch = function(input, init) {
              var url = (input instanceof Request) ? input.url : input;
              var filename = url.split('/').pop().split('?')[0];
              if (['runner.js', 'game.unx', 'runner.data', 'runner.wasm', 'audio-worklet.js'].includes(filename)) {
                  return originalFetch(baseUrl + filename, init);
              }
              return originalFetch(input, init);
          };
          
          // Intercept XHR
          var originalXHR = window.XMLHttpRequest;
          window.XMLHttpRequest = function() {
              var xhr = new originalXHR();
              var originalOpen = xhr.open;
              xhr.open = function(method, url) {
                  var filename = url.split('/').pop().split('?')[0];
                  if (['runner.js', 'game.unx', 'runner.data', 'runner.wasm', 'audio-worklet.js'].includes(filename)) {
                      arguments[1] = baseUrl + filename;
                  }
                  return originalOpen.apply(this, arguments);
              };
              return xhr;
          };

          // Intercept AudioWorklet.addModule
          if (window.AudioWorklet && window.AudioWorklet.prototype.addModule) {
             const originalAddModule = window.AudioWorklet.prototype.addModule;
             window.AudioWorklet.prototype.addModule = function(moduleUrl, options) {
                 var filename = moduleUrl.split('/').pop().split('?')[0];
                 if (filename === 'audio-worklet.js') {
                     return originalAddModule.call(this, baseUrl + filename, options);
                 }
                 return originalAddModule.call(this, moduleUrl, options);
             }
          }
          
          // Inject script
          var script = document.createElement('script');
          script.src = baseUrl + "runner.js";
          document.body.appendChild(script);
      });

      document.getElementById('start-game-btn').addEventListener('click', async function() {
          var fileBlobs = {};

          function addFile(id, name) {
              var input = document.getElementById(id);
              if (input.files && input.files[0]) {
                  fileBlobs[name] = input.files[0];
                  return true;
              }
              return false;
          }

          if (!addFile('file-js', 'runner.js') || !addFile('file-game', 'game.unx') || !addFile('file-data', 'runner.data') || !addFile('file-wasm', 'runner.wasm')) {
              alert("Please upload runner.js, game.unx, runner.data, and runner.wasm.");
              return;
          }
          addFile('file-audio', 'audio-worklet.js');

          document.getElementById('upload-overlay').style.display = 'none';
          document.querySelector('.loading').style.display = 'flex';

          // Get runner code from the uploaded file
          var runnerCode = await fileBlobs['runner.js'].text();

          // Patch audio-worklet if present
          if (fileBlobs['audio-worklet.js']) {
              var audioWorkletUrl = URL.createObjectURL(fileBlobs['audio-worklet.js']);
              runnerCode = runnerCode.replace(/"audio-worklet\.js"/g, '"' + audioWorkletUrl + '"');
          }

          var runnerBlob = new Blob([runnerCode], {type: 'text/javascript'});
          var runnerUrl = URL.createObjectURL(runnerBlob);

          // Setup Module.locateFile to find wasm and data
          Module.locateFile = function(path, prefix) {
              var filename = path.split('/').pop();
              if (fileBlobs[filename]) {
                  return URL.createObjectURL(fileBlobs[filename]);
              }
              return prefix + path;
          };

          // Intercept Fetch for other assets
          var originalFetch = window.fetch;
          window.fetch = function(input, init) {
              var url = (input instanceof Request) ? input.url : input;
              var filename = url.split('/').pop().split('?')[0];
              if (fileBlobs[filename]) {
                  return Promise.resolve(new Response(fileBlobs[filename]));
              }
              return originalFetch(input, init);
          };

          // Intercept XMLHttpRequest
          var originalXHR = window.XMLHttpRequest;
          window.XMLHttpRequest = function() {
              var xhr = new originalXHR();
              var originalOpen = xhr.open;
              xhr.open = function(method, url) {
                  var filename = url.split('/').pop().split('?')[0];
                  if (fileBlobs[filename]) {
                      arguments[1] = URL.createObjectURL(fileBlobs[filename]);
                  }
                  return originalOpen.apply(this, arguments);
              };
              return xhr;
          };

          // Inject runner script
          var script = document.createElement('script');
          script.src = runnerUrl;
          document.body.appendChild(script);
      });
    </script>
  </body>
</html>
